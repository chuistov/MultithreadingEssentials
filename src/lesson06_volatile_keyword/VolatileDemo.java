package lesson06_volatile_keyword;

public class VolatileDemo {

    /**
     * Флаг для совместного использования двумя потоками.
     * Изначально флаг сброшен.
     * Пока он сброшен, первый поток выводит сообщение об этом.
     * Второй поток устанавливает флаг и выводит сообщение об этом.
     * Первый поток прекращает работу.
     *
     * Но есть вероятность того, что первый поток не увидит
     * установленного флага. Тогда цикл первого потока будет бесконечным.
     * Причина этого - многоядерность процессора.
     * Значение флага может кэшироваться в кэше процессорного ядра.
     *
     * Предположим, первый поток работает в первом ядре, а второй поток - во втором ядре.
     * Изначально в кэши обоих ядер берется изначальное значение флага - false.
     * Когда во втором потоке флаг установлен, обновленное значение может не сразу попасть
     * в общую оперативную память, а оттуда - в кэш первого ядра.
     */
//    private static boolean flag = false;

    /**
     * Решение проблемы - ключевое слово volatile.
     * Оно не дает поместить флаг в кэши процессорных ядер
     * (и запрещает другие оптимизации при работе с этой переменной).
     * Значение хранится в одном месте в ОЗУ.
     * Это дольше, но обеспечена целостность данных.
     * Volatile работает только для примитивов и ссылок,
     * но не для значений, хранящихся по ссылке.
     *
     * Имеет ли смысл использовать volatile на одноядерном процессоре?
     * Да, для предотвращения других оптимизаций JVM.
     */
    private static volatile boolean flag = false;

    public static void main(String[] args) throws InterruptedException {
        Thread thread1 = new Thread(() -> {
            while (!flag) {
                System.out.println("still false");
            }
        });
        thread1.start();

        Thread.sleep(1L);

        Thread thread2 = new Thread(() -> {
            flag = true;
            System.out.println("flag is set");
        });
        thread2.start();
    }
}
